#### 问题背景
---
给定字符串s，输出一个二维数组g，g\[i\]\[j\](0<=i<=j<=s.size())表示s[i:j]\(闭区间\)是否为一个回文串
eg：
输入：s="aab"
输出：g={{1,1,0},{1,1,0},{1,1,1}}
> 1表示当前串为回文，否则不是回文；g\[i]\[j] i\>j表示当前是空串，默认为1

#### 问题思考
---
* 首先考虑**暴力做法**，二维循环得到每个i和j，然后使用下面的代码判断回文
`
   	// 分割后每个子串均是回文
	bool judge(const string& target) {
		int len = target.size();
		for(int i = 0; i < len/2; i++) {
			if (target[i] != target[len-1-i]) {
				return false;
			}
		}
		return true;
	}
`
这段代码判断回文串为O(n)，配合上文二维循环，整体时间复杂度：O(n^3)
* 那么如何得到O(n^2)的算法呢
> 使用**dp**

#### dp思路
---
* 问题定义非常明确，主要来看看状态转移方程，换种思路考虑回文，从**中间扩展**的方式考虑一下，g\[i][j]=\(s[i]==s[j]) && g\[i+1][j-1]，从中间的g\[i+1][j-1]向g\[i][j]转移，如果g\[i+1][j-1]为1且s[i]==s[j]，那么说明g\[i][j]也为回文串
* 根据这样的思考，从g\[i+1][j-1] ---> g\[i][j] 说明i是从后向前遍历，而j是从左向右遍历
	// 从中心向两边扩展
	vector<vector<bool>> g(len, vector<bool>(len, true));
	for (int i = len - 1; i >= 0; i--) {
		for (int j = i + 1; j < len; j++) {
			g[i][j] = (s[i] == s[j]) && g[i+1][j-1];
		}
	}
* 时间复杂度：O\(n^2)
