#### A
* 略，基础题
* 注意函数内套函数的写法
```c++
    auto find = [&](string& temp) {
        long long ans = 0;
        for (int i = 0; i < temp.size(); i++) {
            ans = ans * 10 + 1l * (temp - 'a');
        }
        return ans;
    };
```
* 时间复杂度：O(n) 空间复杂度：O(1)
#### B
* 贪心法
* 在十进制数中寻找位置插入x使得这个数最大化，那么如果是负数的时候，要使得数尽量小，而在正数的时候使得数尽可能大，正负不同，任务不同
* 在正数时要使得值尽可能大，那么需要在高位填入大数，即遍历字符串，找到x大于的第一个元素位置；在负数时，从1开始遍历，要使得数值尽可能小，找到x小于的第一个元素位置
* 利用string.insert(int pos, to\_string(x))在指定位置插入即可
* 时间复杂度：O(n) 空间复杂度：O(1)  n为原字符串长度
#### C
* 自定义优先队列
* 设置忙碌队列（根据服务器权重weight和下标进行堆排序）、空闲队列（存放任务完成时间和服务器下标，堆排序）和任务队列
* 注意任务的开始时间，每次从任务队列中弹出任务后，从忙碌队列中抽出空闲的服务器到空闲队列中，从空闲队列中分配服务给到当前作业任务
* 注意只有一台服务器的情况
* 时间复杂度：O(mlogm + n) 空间复杂度：O(m+n) m:服务器数量 n:任务数量
#### D

