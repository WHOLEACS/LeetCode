#### 动态规划
* 定义dp：dp[i]表示s[0:i]\(闭区间)的最大解码总数
* 尝试写状态转移方程
    * 首先考虑s[i]是否为0，如果s[i]为0，那么该0不能单独出现或者作为后面数字的前导0，合法的情况只有和前一位组合（如果前一位不存在直接return 0结束遍历），如果组合成功（10 或者20），此时dp[i] = dp[i-2]，否则0处理失败，return 0即可
    * 其次需要考虑s[i]不为0，此时尝试和前一个字符组合，如果组合数满足[11,26]的区间，组合成功，dp[i] = dp[i-2]\(把当前下标i和下标i-1元素组合展示) + dp[i-1]\(把当前下标i元素单独展示)，否则，组合不成功，此时dp[i] = dp[i-1]即可
* 处理边界情况：dp[0] = s[0] == '0' ? 0 : 1, 如果i-2越界，那么使用if语句表达式版判断 i-2 >= 0 ? dp[i-2] : 1
* 时间复杂度：O(n) 空间复杂度：O(n)
