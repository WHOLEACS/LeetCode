#### 方法一. 栈 AC
* 使用单调栈来进行中缀表达式到后缀表达式的转换，我们发现优先级较低的运算符最后执行，同级运算符（如+和-）总是从左向右执行，使用运算符优先级从小到大构造单调栈，如果当前遍历指向的下标处运算符优先级小于等于栈顶运算符优先级，那么把栈中元素出栈直到栈为空或者栈顶运算符小于当前运算符，根据这样的方式生成了后缀表达式
    * 时间复杂度：O(n) 空间复杂度：O(n)
* 使用栈操作完成后缀表达式的四则运算，遇到数字入栈，遇到符号把栈顶两个数字弹出做运算（注意区分左右），然后把结果入栈，最终取栈顶元素即是解
---
#### 方法二. 表达式树 TLE
* 使用表达式树来进行中缀表达式到后缀表达式的转换，根据前面单调栈给出的经验，优先级较低的运算符排在最后，对于表达式树来说，其后序遍历就是后缀表达式，我们每次拿到当前字符串中优先级最低的运算符作根，通过下标把字符串分成两个部分分别代表根节点的左右子树，递归向下进行处理直到当前字符串是一个数字（表达式树非叶子节点代表运算符，叶子节点表示参与运算的数字）
* 重点在于如何在一个字符串中找到优先级最低的运算符，有几种情况：1. 括号会提高优先级 eg:(1+2)\*3 2. 同级运算符如何处理 eg:1+2-4 我们在进行运算的时候，应该是从左向右的顺序，那么说明处于最后的运算符优先级最低，所以这种情况下应该选择最右的同级运算符
```
	// 找到当前根节点，优先级最低的运算符 如果运算符优先级相同，选择最右边的，因为同级运算满足从左向右的规则
    // p表示括号嵌套层级关系
	int p = 0;
    // c1表示加减的最后位置， c2表示乘除的最后位置
	int c1 = -1, c2 = -1;
	for(int i = left; i <= right; i++)
	{
		switch(target[i])
		{
			case '(': p++; break;
			case ')': p--; break;
			case '+': case '-': if(!p) c1 = i; break;
			case '*': case '/': if(!p) c2 = i; break;
		}
	}
	if(c1 < 0) c1 = c2;		//找不到括号外的加减号，就用乘除号
	if(c1 < 0) return create_Tree(target, left+1, right-1);		//整个表达式被一对括号括起来
```
* 时间复杂度：O(n^2) 在极端情况下，树会退化成链表，长度为n，平均复杂度：O(nlogn)
#### 方法三. 
