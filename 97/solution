动态规划，题中的|n - m| <= 1是一个迷惑条件，这个条件其实没用，任何一个可以转移得到的状态最终都可以满足这个条件
双指针做法不可取的原因是无法明确得到当前s3字符串的元素是由哪个字符串的当前指针所指元素得到，而动态规划都会去进行尝试。
动态规划三要素：问题定义，状态定义   明确转移方程  明确边界情况
我们设F[i,j]表示s1的前i个元素和s2的前j个元素能否组成s3的前i+j个元素，我们缩小问题，可以转化成F[i-1,j]和s1[i]==s3[i+j]是否同时成立，即看s1的前i-1个元素和s2的前j个元素是否能够组成s3的前i+j-1个元素；或者换种转移方式，可以看s1的前i个元素和s2的前j-1个元素是否能够组成s3的前i+j-1个元素并且s2的第j个元素是否和s3的第i+j个元素相等
写出转移方程 F[i,j] = (F[i-1,j] and s1[i] == s3[i+j]) or (F[i,j-1] and s2[j] == s3[i+j])
最后是边界情况F[0,0] = True
由于当前行只与它的前一行元素相关，那么我们可以使用滚动数组的方式优化空间复杂度
时间复杂度：O(n*m) 空间复杂度：O(m) n:s1.size() m:s2.size()
