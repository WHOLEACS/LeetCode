链表重排，易得出这道题有重复子问题的性质，所以可以使用递归。
我们首先把这个链表存下来方便处理，这是因为当前链表结构是单链表，如果想要访问一个链表节点的前驱节点，那么只能重新来遍历一次链表，这样的时间消耗很大
我们每次传入当前剩余链表的头节点和尾节点，把当前头节点指向尾节点（注意尾节点的next指针首先要设置成nullptr），随后把原问题缩小，给下层递归函数传入剩余链表的头节点和尾节点
并且回传当前链表的头节点。结束条件是头尾相同或者头的下一个节点就是尾节点，这个时候不需要做处理，直接返回当前链表头节点即可。
